# a0
The logic for the first code was initially discussed with Yash Shah, mail: yashah@iu.edu.

This report and the programs are made by Ritwik Budhiraja, mail ID: rbudhira@iu.edu.

A1. The code is implementing search algorithm 1(DFS) because it is making use of a stack and it does not explore all the nodes before going on to a 'next' node. Because of such implementation, it was encountering an infinite loop. I got rid of that loop by creating a list of visited nodes and then only appended those nodes to the fringe that were not present in that list. I also made a string that stores the directions of the moves made through a function. I also made the string variable part of the fringe, so that every time a move is made, the fringe stores the direction too. In total, I have implemented DFS with a stack that also does not encounter any infinite loop. Initially, I tried to implement different techniques such as calculating the coordinates of a person in the beginning and then thinking of ways that would lead to no solution. I had tried to appoint X to visited nodes to prevent them from being visited again, but that introduced another infinite loop. All the initial attempts are still commented to describe the process of reaching the final approach. The set of valid states includes all the states in which Pichu is present on a '.' space and not an 'X' space. The successor function includes all the states in which we move from the current position of Pichu to the next, where '.' is present and not an 'X'. The cost function is the cost encountered in moving from one position to the next valid position. In this case, it is uniform. The initial state is the state in which Pichu is present at the first node provided in the map and the final state is one in where Pichu reaches the person.

A2. # Initial Commit: The second code was also using Search Algorithm 1. I changed it to Search Algorithm 2 thinking that I would be able to implement a Heuristic function but could not. The code was originally putting a Pichu at every '.' position. So I made a function to include the constraints as asked by the question. The function only puts a Pichu at a '.' if there are no other Pichus present in the same row, column or diagonal. If there is another Pichu in the same row, column, or diagonal, it looks for an 'X' or '@' in between and if encountered, then only puts the Pichu. Unfortunately, the output is not coming out as expected and I am still working on the code. I've pushed the current files for now. 

#Final Commit: Following the initial commit, here are the final changes that I have made to the code to make it fully functional. I worked on the nomenclature of a few variables to make a better understanding of them while debugging. The blocks to check the constraints on the diagonals were too long and thus I compressed them into a single block of code. This eliminated the need to check each upper-left, bottom-left, upper-right, and bottom-right diagonals separately. In the initial commit, the program was checking the conditions using a logical 'OR' but now it returns the 'AND' value of all the three conditions (Rows, Columns, and Diagonals)

The state space includes all the states in which Pichu is present on a '.' space and not an 'X' space. The initial state is the state in which 1 Pichu is present at a '.' and goal state is the map in which k pichus are present, wherein they are not placed in the same diagonal, row, or column or they have an 'X'/'@' in between if placed in the same directions. Successor function includes all the states in which 1 more pichu is present than the previous state satisfying the constraints. The cost function is the cost encountered in placing another Pichu.
